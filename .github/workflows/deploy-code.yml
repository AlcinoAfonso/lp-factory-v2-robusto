name: Deploy Code from Claude

on:
  workflow_dispatch:
    inputs:
      title:
        description: 'T√≠tulo do PR/Commit'
        required: true
        type: string
      description:
        description: 'Descri√ß√£o do que est√° sendo implementado'
        required: false
        type: string
        default: 'C√≥digo gerado via Claude'
      code_content:
        description: 'C√≥digo completo do Claude (cole aqui)'
        required: true
        type: string
      target_branch:
        description: 'Branch de destino'
        required: false
        type: string
        default: 'main'

jobs:
  process-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create Feature Branch
        id: create_branch
        run: |
          # Gera nome √∫nico para a branch
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          BRANCH_NAME="claude-deploy-${TIMESTAMP}"
          echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          
          # Cria e muda para nova branch
          git checkout -b $BRANCH_NAME

      - name: Process Claude Code
        id: process_code
        run: |
          # Salva o conte√∫do em um arquivo tempor√°rio
          cat > claude_input.txt << 'CLAUDE_EOF'
          ${{ github.event.inputs.code_content }}
          CLAUDE_EOF
          
          # Script Python para processar o c√≥digo
          cat > process_claude.py << 'PYTHON_EOF'
          import re
          import os
          import json
          
          def extract_files_from_claude(content):
              """
              Extrai arquivos do formato Claude:
              - Detecta blocos de c√≥digo com nome de arquivo
              - Suporta m√∫ltiplos formatos de indica√ß√£o de arquivo
              """
              files = []
              
              # Padr√µes para detectar arquivos
              patterns = [
                  # Padr√£o 1: ```language filename
                  r'```(?P<lang>\w+)\s+(?P<path>[\w\-/\.]+)\n(?P<content>.*?)```',
                  # Padr√£o 2: // filename ou # filename no in√≠cio do bloco
                  r'```(?P<lang>\w+)\n(?://|#)\s*(?P<path>[\w\-/\.]+)\n(?P<content>.*?)```',
                  # Padr√£o 3: File: filename antes do bloco
                  r'(?:File:|Arquivo:)\s*(?P<path>[\w\-/\.]+)\n```(?P<lang>\w+)\n(?P<content>.*?)```',
                  # Padr√£o 4: Criando arquivo: filename
                  r'(?:Criando arquivo:|Creating file:)\s*(?P<path>[\w\-/\.]+)\n```(?P<lang>\w+)\n(?P<content>.*?)```',
              ]
              
              for pattern in patterns:
                  matches = re.finditer(pattern, content, re.DOTALL | re.MULTILINE)
                  for match in matches:
                      file_path = match.group('path')
                      file_content = match.group('content')
                      
                      # Remove espa√ßos extras no final
                      file_content = file_content.rstrip()
                      
                      files.append({
                          'path': file_path,
                          'content': file_content
                      })
              
              # Se n√£o encontrou arquivos com os padr√µes acima,
              # tenta detectar estrutura mais livre
              if not files:
                  # Busca todos os blocos de c√≥digo
                  code_blocks = re.finditer(r'```(?P<lang>\w*)\n(?P<content>.*?)```', content, re.DOTALL)
                  
                  for block in code_blocks:
                      content_lines = block.group('content').split('\n')
                      if content_lines:
                          first_line = content_lines[0].strip()
                          
                          # Verifica se a primeira linha parece um caminho de arquivo
                          if ('/' in first_line or '.' in first_line) and len(first_line) < 100:
                              # Assume que a primeira linha √© o caminho
                              file_path = first_line.strip('/#: ')
                              file_content = '\n'.join(content_lines[1:])
                              
                              files.append({
                                  'path': file_path,
                                  'content': file_content.rstrip()
                              })
              
              return files
          
          # L√™ o conte√∫do do Claude
          with open('claude_input.txt', 'r', encoding='utf-8') as f:
              claude_content = f.read()
          
          # Extrai arquivos
          files = extract_files_from_claude(claude_content)
          
          # Salva lista de arquivos processados
          with open('files_to_create.json', 'w', encoding='utf-8') as f:
              json.dump(files, f, indent=2)
          
          # Cria os arquivos
          created_files = []
          for file_info in files:
              file_path = file_info['path']
              file_content = file_info['content']
              
              # Cria diret√≥rios se necess√°rio
              dir_path = os.path.dirname(file_path)
              if dir_path:
                  os.makedirs(dir_path, exist_ok=True)
              
              # Escreve o arquivo
              with open(file_path, 'w', encoding='utf-8') as f:
                  f.write(file_content)
                  if not file_content.endswith('\n'):
                      f.write('\n')
              
              created_files.append(file_path)
              print(f"Criado: {file_path}")
          
          # Salva lista de arquivos criados para o workflow
          with open('created_files.txt', 'w') as f:
              f.write('\n'.join(created_files))
          
          print(f"\nTotal de arquivos criados: {len(created_files)}")
          PYTHON_EOF
          
          # Executa o processador
          python3 process_claude.py
          
          # Salva informa√ß√µes para pr√≥ximos steps
          echo "files_created=$(cat created_files.txt | wc -l)" >> $GITHUB_OUTPUT

      - name: Commit Changes
        id: commit
        run: |
          # Adiciona todos os arquivos criados
          if [ -f created_files.txt ]; then
            while IFS= read -r file; do
              git add "$file"
            done < created_files.txt
          fi
          
          # Faz o commit
          git commit -m "${{ github.event.inputs.title }}" \
            -m "${{ github.event.inputs.description }}" || echo "No changes to commit"
          
          # Push da branch
          git push origin ${{ steps.create_branch.outputs.branch_name }}

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ steps.create_branch.outputs.branch_name }}
          base: ${{ github.event.inputs.target_branch }}
          title: ${{ github.event.inputs.title }}
          body: |
            ## ü§ñ C√≥digo Gerado via Claude
            
            **Descri√ß√£o:** ${{ github.event.inputs.description }}
            
            ### üìÅ Arquivos Criados/Modificados
            
            Esta PR foi gerada automaticamente a partir de c√≥digo fornecido pelo Claude.
            
            <details>
            <summary>Ver lista de arquivos (${{ steps.process_code.outputs.files_created }} arquivos)</summary>
            
            ```
            ${{ steps.process_code.outputs.file_list }}
            ```
            
            </details>
            
            ### ‚úÖ Checklist
            
            - [ ] C√≥digo revisado
            - [ ] Testes executados (se aplic√°vel)
            - [ ] Documenta√ß√£o atualizada (se necess√°rio)
            - [ ] Sem conflitos com a branch principal
            
            ### üîó Informa√ß√µes Adicionais
            
            - **Branch:** `${{ steps.create_branch.outputs.branch_name }}`
            - **Autor:** GitHub Actions Bot
            - **Trigger:** Manual via workflow_dispatch
            - **Timestamp:** ${{ steps.create_branch.outputs.timestamp }}
            
            ---
            
            *Este PR foi criado automaticamente. Por favor, revise o c√≥digo antes de fazer merge.*
          
          labels: |
            automated
            claude-generated
            needs-review
          
          assignees: ${{ github.actor }}
          reviewers: ${{ github.actor }}
          draft: false

      - name: PR Summary
        if: success()
        run: |
          echo "‚úÖ Pull Request criado com sucesso!"
          echo "üìÅ Arquivos processados: ${{ steps.process_code.outputs.files_created }}"
          echo "üåø Branch: ${{ steps.create_branch.outputs.branch_name }}"
          echo "üîó Acesse o PR para revisar e fazer merge"

      - name: Cleanup
        if: always()
        run: |
          # Remove arquivos tempor√°rios
          rm -f claude_input.txt process_claude.py files_to_create.json created_files.txt
